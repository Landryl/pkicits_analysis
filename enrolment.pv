(******************************************************************************)
(* Elliptic Curve Equations *)
type point.
type scalar.

const G: point [data].
fun mul(scalar, point): point.
equation forall x: scalar, y: scalar; mul(y, mul(x, G)) = mul(x, mul(y, G)).

(* For lisibility, conversions functions *)
type skey.
type pkey.
fun skey_to_scalar(skey): scalar [data, typeConverter].
fun pkey_to_point(pkey): point [data, typeConverter].

fun pk(skey): pkey.
equation forall x:skey; pkey_to_point(pk(x)) = mul(skey_to_scalar(x), G).

fun pkey_to_bitstring(pkey): bitstring [data, typeConverter].

(* Symmetric encryption *)
type key.

(* As stated in ProVerif user manual, basic encryption is already authenticated,
   so no need for a MAC key *)
fun kdf(point): key.

(* Used to encrypt message, implemented using AES in the standard *)
fun senc(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; sdec(senc(m, k), k) = m.

(* Used to encrypt keys, implemented using XOR in the standard *)
fun senck(key, key): bitstring.
reduc forall km: key, k: key; sdeck(senck(km, k), k) = km.

fun sign(bitstring, skey): bitstring.
reduc forall m: bitstring, sk: skey; getmsg(sign(m, sk)) = m.
reduc forall m: bitstring, sk: skey; checksign(sign(m, sk), pk(sk)) = true.

fun concat(bitstring): bitstring [data].

(* ECIES *)

letfun ecies_enc(m:bitstring, pk:pkey) =
    new k:key;
    new r:scalar;
    let V = mul(r, G) in
    let S = mul(r, pkey_to_point(pk)) in
    let derived_key = kdf(S) in
    concat((
        (senc(m, k), senck(k, derived_key), V),
        k)).

letfun ecies_dec(m:bitstring, sk:skey) =
    let concat(
                (encrypted_msg:bitstring, encrypted_key:bitstring, V:point)
              ) = m in
    let S = mul(skey_to_scalar(sk), V) in
    let derived_key = kdf(S) in
    let k = sdeck(encrypted_key, derived_key) in
    concat((sdec(encrypted_msg, k), k)).

(******************************************************************************)

free c:channel.

event StationSentECRequest.
event StationReceivedECResponse.
event EAReceivedValidECRequest.
event EASentECResponse.

(* confidentiality of the canonical key *)
query attacker(new sks).

(* authentication of response should hold *)
query inj-event(StationReceivedECResponse) ==> inj-event(EASentECResponse).

(* authentication of request does not hold *)
query inj-event(EAReceivedValidECRequest) ==> inj-event(StationSentECRequest).

(* Sanity check, making sure all branches are reachables. Theses queries should
   return false *)
(* query event(EAReceivedValidECRequest). *)
(* query event(EASentECResponse).         *)
(* query event(StationSentECRequest).     *)
(* query event(StationReceivedECResponse).*)

let Station(sks:skey, pkea:pkey) =
    (* Make request - Etsi 102941 6.2.3.2.1 *)
    new verificationSKey:skey;
    let verificationPKey = pk(verificationSKey) in
    let tbsKey = pkey_to_bitstring(verificationPKey) in

    (* Proof of Possession *)
    let inner_request = sign(tbsKey, verificationSKey) in
    let outer_request = sign(inner_request, sks) in

    event StationSentECRequest;

    let concat(
            (encrypted_request:bitstring, k:key)
              ) = ecies_enc(outer_request, pkea) in
    out(c, encrypted_request);

    (* Receive answer *)
    in(c, encrypted_answer:bitstring);
    let answer = sdec(encrypted_answer, k) in
    if checksign(answer, pkea) then
        event StationReceivedECResponse.

let EnrolmentAuthority(skea:skey, pks:pkey) =
    in(c, encrypted_request:bitstring);
    let concat(
            (request:bitstring, k:key)
              ) = ecies_dec(encrypted_request, skea) in

    (* Process the request *)
    (** Check outer signature **)
    if checksign(request, pks) then
    let innerrequest = getmsg(request) in
    (** Check inner signature **)
    let pkey_to_bitstring(innerkey) = getmsg(innerrequest) in
    if checksign(innerrequest, innerkey) then

    event EAReceivedValidECRequest;

    (** Sign provided key **)
    let res = sign(pkey_to_bitstring(innerkey), skea) in

    (* Send request results *)
    event EASentECResponse;
    out(c, senc(res, k)).

process
    new sks:skey;
    new skea:skey;
    (     (!Station(sks, pk(skea)))
        | (!EnrolmentAuthority(skea, pk(sks)))
    )
