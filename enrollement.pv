(******************************************************************************)
(* Elliptic Curve Equations *)
type point.
type scalar.

const G: point [data].
fun mul(scalar, point): point.
equation forall x: scalar, y: scalar; mul(y, mul(x, G)) = mul(x, mul(y, G)).

(* For lisibility, conversions functions *)
type skey.
type pkey.
fun skey_to_scalar(skey): scalar [data, typeConverter].
fun pkey_to_point(pkey): point [data, typeConverter].

fun pk(skey): pkey.
equation forall x:skey; pkey_to_point(pk(x)) = mul(skey_to_scalar(x), G).

(* Symmetric encryption *)
type key.

(* As stated in ProVerif user manual, basic encryption is already authenticated,
   so no need for a MAC key *)
fun kdf(point): key.

(* Used to encrypt message, implemented using AES in the standard *)
fun senc(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; sdec(senc(m, k), k) = m.

(* Used to encrypt keys, implemented using XOR in the standard *)
fun senck(key, key): bitstring.
reduc forall km: key, k: key; sdeck(senck(km, k), k) = km.

(* Identity *)
type host.

(* Certificates *)
type certificate.

(******************************************************************************)

table CTL(host, certificate).
table CRL(host, certificate).

free c:channel.
free InnerECRequest:bitstring [private].

query attacker(InnerECRequest).

let RCA() =
    in(c, req:host);
    get CTL(=req, cert:certificate) in
        out(c, cert)
    else 0.

let Station(sks:skey, pkea:pkey) =
    (* Make request - Etsi 102941 6.2.3.2.1 *)
    (* TODO *)

    (* Encrypt request using a fresh key *)
    new k:key;
    out(c, senc(InnerECRequest, k));

    (* Send fresh key using ECIES *)
    new r:scalar;
    let pkey_client = mul(skey_to_scalar(sks), G) in
    let V = mul(r, G) in
    let S = mul(r, pkey_to_point(pkea)) in
    let derived_key = kdf(S) in
    out(c, senck(k, derived_key));
    out(c, V);

    (* Receive answer *)
    in(c, encrypted_answer:bitstring);
    let answer = sdec(encrypted_answer, k) in
        0.

let EnrollementAuthority(skea:skey, pks:pkey) =
    (* Receive encrypted request *)
    in(c, encrypted_request:bitstring);

    (* Receive encrypted key *)
    in(c, encrypted_key:bitstring);
    in(c, V:point);

    (* Decryption *)
    let S = mul(skey_to_scalar(skea), V) in
    let derived_key = kdf(S) in
    let k = sdeck(encrypted_key, derived_key) in
    let request = sdec(encrypted_request, k) in

    (* Process the request *)
    if request = InnerECRequest then

    (* Send request results *)
    new cert:bitstring;
    out(c, senc(cert, k)).

process
    new skrca:skey;
    new sks:skey;
    new skea:skey;
    (     (!RCA)
        | (!Station(sks, pk(skea)))
        | (!EnrollementAuthority(skea, pk(sks)))
    )
